
    
    @staticmethod
    def elementwise_division(data_dict):
        cols = list(data_dict.keys())
        data_mat = np.array([[ (v if v is not None else 0) for v in data_dict[c]] for c in cols]).T
        n_rows, n_cols = data_mat.shape
        result = [[0.0 for _ in range(n_cols - 1)] for _ in range(n_rows)]

        for i in range(n_rows):
            for j in range(1, n_cols):
                prev, curr = float(data_mat[i, j-1]), float(data_mat[i, j])
                if prev == 0.0:
                    # 0→0 lub 0→>0: ustaw 1.0 (neutralny czynnik); i tak ma wagę 0 gdy wiersz pusty
                    result[i][j-1] = 1.0
                else:
                    result[i][j-1] = curr / prev
        return result


    @staticmethod
    def Dev_prem(paid: pd.DataFrame, w: pd.DataFrame):
        n_cols = paid.shape[1]
        n_rows = paid.shape[0]
        dev = []
        for j in range(n_cols - 1):
            rng = min(n_rows, n_cols - j - 1)
            den = 0.0
            num = 0.0
            for i in range(rng):
                den += float(paid.iloc[i, j])   * float(w.iloc[i, j])
                num += float(paid.iloc[i, j+1]) * float(w.iloc[i, j])
            dev.append(1.0 if den == 0.0 else num/den)
        return dev

    @staticmethod
    def calculate_sigma(p_ij, l_ij, w_ij, dev_j):
        max_col = l_ij.shape[1]
        sigmas, sd = [], []
        for j in range(max_col):
            num = den = den_sd = 0.0
            for i in range(len(l_ij)):
                try:
                    w = float(w_ij.iloc[i, j]); p = float(p_ij.iloc[i, j]); l = float(l_ij.iloc[i, j])
                except (IndexError, ValueError): 
                    continue
                if not (np.isfinite(w) and np.isfinite(p) and np.isfinite(l)): 
                    continue
                num += w * p * (l - dev_j[j])**2
                den += w
                den_sd += w * p

            if den > 1.0:
                sigma = np.sqrt(num / (den - 1.0))
                sd.append( sigma/np.sqrt(den_sd) if den_sd > 0.0 else 0.0 )
            else:
                sigma = 0.0
                sd.append(0.0)
            sigmas.append(sigma)
        return [sigmas, sd]
