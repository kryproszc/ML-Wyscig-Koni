

## incurred

class IncurredTriangleRequest(BaseModel):
    user_id: str
    incurred_data_det: List[List[Union[str, int, float, None]]]
    weights: Optional[List[List[int]]] = None


class IncurredCLRequest(BaseModel):
    user_id: str
    incurred_data_det: List[List[Union[str, int, float, None]]]
    weights: List[List[int]]

@app.post("/calc/incurred/train_devide_incurred")
async def calc_incurred_train_devide(payload: IncurredTriangleRequest):
    data = {}
    headers = [x for x in range(len(payload.incurred_data_det[0]))]
    for i, col in enumerate(headers):
        data[col] = []
        for row in payload.incurred_data_det:
            value = row[i]
            try:
                num_value = float(value)
            except (ValueError, TypeError):
                num_value = None
            data[col].append(num_value)

    train_devide = TriangleCalculator.elementwise_division(data)
    train_devide_serializable = np.array(train_devide).tolist()
    return {"train_devide": train_devide_serializable}


@app.post("/calc/incurred/cl")
async def calc_incurred_cl(payload: IncurredCLRequest):
    incurred_data = payload.incurred_data_det
    weights = payload.weights

    data = {}
    headers = np.arange(len(incurred_data[0]))
    for i, col in enumerate(headers):
        data[col] = []
        for row in incurred_data:
            value = row[i]
            try:
                num_value = float(value)
            except (ValueError, TypeError):
                num_value = None
            data[col].append(num_value)

    l_ij = pd.DataFrame(TriangleCalculator.elementwise_division(data))
    w_ij = pd.DataFrame(weights)
    p_ij = pd.DataFrame(data)
    dev_j = TriangleCalculator.Dev_prem(p_ij, w_ij)

    return {
        "message": "Odebrano dane i zastosowano wagi",
        "dev_j": list(dev_j),
    }



class SelectedDevJRequest(BaseModel):
    user_id: Optional[str] = None
    selected_dev_j: List[float]
    selected_indexes: Optional[List[int]] = None
    tail_values: Optional[List[float]] = None
    full_dev_j: List[float]            # pełen wektor dev_j

# -------------------------------------------------------------------
# ENDPOINT – istniejący (Paid) NIE zmieniamy
# -------------------------------------------------------------------
@app.post("/calc/paid/selected_dev_j")
async def calc_paid_selected_dev_j(payload: SelectedDevJRequest):
    return _process_selected_dev_j(payload)   # <‑‑ patrz funkcja pomocnicza


# -------------------------------------------------------------------
# ENDPOINT – NOWY wariant Incurred
# -------------------------------------------------------------------
@app.post("/calc/incurred/selected_dev_j")
async def calc_incurred_selected_dev_j(payload: SelectedDevJRequest):
    return _process_selected_dev_j(payload)   # logika współdzielona


# -------------------------------------------------------------------
# WSPÓLNA FUNKCJA POMOCNICZA
# -------------------------------------------------------------------
def _process_selected_dev_j(payload: SelectedDevJRequest):
    """
    Wspólna logika dla wariantów Paid / Incurred.
    """
    # ▸ wektor pełny
    full_ys = np.array(payload.full_dev_j, dtype=float)

    # ▸ punkty wybrane przez użytkownika
    xs = np.array(payload.selected_indexes or [], dtype=float) + 1  # indeksy 1‑based
    ys = np.array(payload.selected_dev_j, dtype=float)

    # ▸ dopasowanie krzywych
    curve_list = ["Exponential", "Weibull", "Power", "Inverse Power"]
    parameters_curve = calculator_det.parameters_curve_reservoir(
        xs=xs, ys=ys, lista_krzywych=curve_list
    )

    # ▸ symulacja
    tail = int(payload.tail_values[0]) if payload.tail_values else 0
    xs_sim = np.array([i + 1 for i in range(len(full_ys) + tail)], dtype=float)
    simulation_results = calculator_det.sim_data_curve_rezerwy(
        xs_sim, curve_list, parameters_curve
    )

    # ▸ R²
    f_curves_graph_real_choose = calculator_det.sim_data_curve_rezerwy(
        xs, curve_list, parameters_curve
    )
    r2_curves_df = calculator_det.r2_curves(f_curves_graph_real_choose, ys)

    return {
        "simulation_results": simulation_results.to_dict(),
        "r2_scores": r2_curves_df.to_dict(),
    }



class SaveVectorRequest(BaseModel):
    curve_name:        Optional[str]        = None   # symulowana krzywa CL
    coeffs:            Optional[List[float]] = None  # ⬆ jej współczynniki
    volume:            Optional[int]         = None  # dev_j z konkretnego volume
    values:            Optional[List[float]] = None  # ⬆ jego wektor dev_j
    final_dev_vector:  Optional[List[float]] = None  # gotowy dev_final / combined


# ──────────────────────────────────────────────────────────────────────────────
#  2. Cały payload: trójkąt incurred + dokładnie 2 zestawy współczynników
# ──────────────────────────────────────────────────────────────────────────────
class SaveVectorPayload(BaseModel):
    incurred_data_det: List[List[Optional[float]]]
    coeff_sets:        List[SaveVectorRequest]


# ──────────────────────────────────────────────────────────────────────────────
#  3. Pomocnicza funkcja – wyciąga wektor z SaveVectorRequest
# ──────────────────────────────────────────────────────────────────────────────
def _extract_vector(p: SaveVectorRequest) -> List[float]:
    if p.curve_name and p.coeffs:
        return p.coeffs
    if p.volume is not None and p.values:
        return p.values
    if p.final_dev_vector:
        return p.final_dev_vector
    raise HTTPException(
        status_code=422,
        detail="❌ Nieprawidłowy format jednego z obiektów (brak danych wektora).",
    )


# ──────────────────────────────────────────────────────────────────────────────
#  4. Endpoint  POST /calc/incurred/save_vector
# ──────────────────────────────────────────────────────────────────────────────
@app.post("/calc/incurred/save_vector")
async def save_vector_incurred(payload: SaveVectorPayload):
    # 4.a – walidacja liczby zestawów
    if len(payload.coeff_sets) != 2:
        raise HTTPException(
            status_code=400,
            detail="❌ Oczekiwano dokładnie 2 zestawów współczynników (A i B).",
        )

    # 4.b – wyciągamy dwa wektory
    vector_a = _extract_vector(payload.coeff_sets[0])
    vector_b = _extract_vector(payload.coeff_sets[1])

    # 4.c – budujemy DataFrame z trójkąta incurred
    df_triangle = (
        pd.DataFrame(payload.incurred_data_det)
        .apply(pd.to_numeric, errors="coerce")
        .drop(columns="AY", errors="ignore")          # jeśli nagłówek AY istnieje
    )

    # 4.d – projekcje (używamy Twojej istniejącej util‑funkcji)
    df_proj_a = calculator_det.triangle_forward(df_triangle, vector_a, 1)
    df_proj_b = calculator_det.triangle_forward(df_triangle, vector_b, 1)

    # 4.e – ostatnie nie‑NaN‑y w wierszach
    last_a = df_proj_a.apply(lambda r: r.dropna().iloc[-1], axis=1)
    last_b = df_proj_b.apply(lambda r: r.dropna().iloc[-1], axis=1)

    diff_abs = last_a - last_b
    diff_pct = (diff_abs / last_a.replace({0: pd.NA})) * 100

    # 4.f – tabela porównania
    df_cmp = pd.DataFrame(
        {
            "Wiersz":        range(len(df_proj_a)),
            "Projection A":  last_a.round(2),
            "Projection B":  last_b.round(2),
            "Różnica":       diff_abs.round(2),
            "Różnica %":     diff_pct.round(2),
        }
    )

    # wiersz SUMA
    sum_a, sum_b = last_a.sum(), last_b.sum()
    sum_diff     = sum_a - sum_b
    sum_pct      = (sum_diff / sum_a * 100) if sum_a != 0 else None

    df_cmp.loc["Suma"] = {
        "Wiersz":       "Suma",
        "Projection A": round(sum_a, 2),
        "Projection B": round(sum_b, 2),
        "Różnica":      round(sum_diff, 2),
        "Różnica %":    round(sum_pct, 2) if sum_pct is not None else None,
    }

    # 4.g – zwrot dla front‑endu
    return {
        "wektor_a":      vector_a,
        "wektor_b":      vector_b,
        "triangle_rows": len(payload.incurred_data_det),
        "comparison":    df_cmp.to_dict(orient="records"),
    }
