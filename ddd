@njit(fastmath=True, parallel=False)    # parallel=True → pętla i, jeśli chcesz
def triangle_forward_loss_ratio_numba(
        tri_in: np.ndarray,             # macierz trójkąta (mm × n_cols)
        LR_j:   np.ndarray,             # wektor współczynników LR
        exposure: np.ndarray,           # wektor ekspozycji (dł. = mm)
        k_forward: int                  # ile okresów „do przodu”
) -> np.ndarray:
    """
    Zwraca nową macierz trójkąta z wypełnionymi kolumnami j+1.

    • Jeśli LR_j jest dłuższe niż liczba kolumn, macierz jest rozszerzana
      do (len(LR_j)+1) kolumn i wypełniana NaN-ami (dokładnie jak w pandas).

    • Wynik ma typ float64 i zawiera NaN (= np.nan) tam, gdzie oryginał
      miał None/NaN albo gdzie kolumny zostały dopisane.
    """
    mm, n_cols_orig = tri_in.shape
    n_cols_out = max(n_cols_orig, len(LR_j) + 1)      # +1 bo j+1

    # ---- alokujemy wynik i kopiujemy istniejący trójkąt -----------------
    tri = np.empty((mm, n_cols_out), dtype=np.float64)
    tri[:] = np.nan                                   # domyślnie NaN

    for i in range(mm):
        for j in range(n_cols_orig):
            tri[i, j] = tri_in[i, j]

    # ---- wypełniamy forward (zgodnie z Twoją logiką) --------------------
    for j in range(k_forward):
        max_ind_row = 1 if (mm - j) < 1 else (mm - j)   # max(1, mm-j)
        start_row = max_ind_row - 1                     # 0-based

        # pętla po wierszach
        for i in range(start_row, mm):
            base_val = tri[i, j]                        # może być NaN
            tri[i, j + 1] = base_val + exposure[i] * LR_j[j]

    return tri
