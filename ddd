from numba import njit
import numpy as np

@njit
def fit_curve_factor_lr(data_input, sd_input, x_k):
    """
    Log‑linear fit: ln(f) = a * k + b
    Z wagami odwrotnie proporcjonalnymi do błędu LR (zgodnie z Mackiem).
    """
    n = len(data_input)
    se2 = sd_input ** 2
    w = np.empty(n)
    for i in range(n):
        denom = data_input[i] ** 2
        if denom > 0.0:
            w[i] = 1.0 / np.sqrt(np.log(1.0 + se2[i] / denom))
        else:
            w[i] = 1.0

    y = np.empty(n)
    for i in range(n):
        if data_input[i] > 0.0:
            y[i] = np.log(data_input[i])
        else:
            y[i] = 0.0  # lub np.nan, jeśli chcesz filtrować

    A = A_x = A_xx = A_y = A_xy = 0.0
    for i in range(n):
        wi = w[i]
        xi = x_k[i]
        yi = y[i]
        A += wi
        A_x += wi * xi
        A_xx += wi * xi * xi
        A_y += wi * yi
        A_xy += wi * xi * yi

    Delta = A * A_xx - A_x * A_x
    if Delta == 0.0:
        return 0.0, 0.0

    a_coef = (A * A_xy - A_x * A_y) / Delta
    b_coef = (A_xx * A_y - A_x * A_xy) / Delta
    return a_coef, b_coef
