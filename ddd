from numba import njit, prange
import numpy as np

@njit(parallel=True)
def stochastic_triangle_forward_test_szybki_batched(
    reserv_array,
    sigma_j,
    dev,
    sd,
    e_values,
    sim_total=100_000,
    batch_sim=1_000,
    ultimate_param_resrisk=0.0,
    main_seed=202260011
):
    """
    Wersja z batchingiem i pełną obsługą symulacji w jednej funkcji.
    Zwraca tablicę shape (sim_total,), zawierającą różnicę między sumą z ostatniej kolumny
    a wartością parametru rezerwowego.
    """
    mm, n_cols_orig = reserv_array.shape
    n_dev = len(dev)
    n_batches = sim_total // batch_sim
    results = np.zeros(sim_total)

    for batch_idx in prange(n_batches):
        np.random.seed(main_seed + batch_idx)

        mu_part = np.empty((batch_sim, n_dev))
        sigma_part = np.empty((batch_sim, n_dev))

        for j in range(n_dev):
            mu_part[:, j] = np.random.normal(dev[j], sd[j], batch_sim)
            df = max(1, mm - j)
            chi = np.random.chisquare(df, batch_sim)
            for s in range(batch_sim):
                sigma_part[s, j] = (chi[s] * sigma_j[j]) / df

        for i in range(batch_sim):
            m_i = mu_part[i]
            s_i = sigma_part[i]

            n_cols_target = n_dev + 1
            tri_copy = np.zeros((mm, n_cols_target))

            # kopiowanie danych wejściowych
            for r in range(mm):
                for c in range(n_cols_orig):
                    tri_copy[r, c] = reserv_array[r, c]

            for j in range(n_dev):
                max_row = max(1, mm - j)
                for r in range(max_row):
                    VAR_i_j = s_i[j] * e_values[r]
                    if m_i[j] >= 0:
                        m2 = m_i[j] ** 2
                        denom = np.sqrt(m2 + VAR_i_j)
                        if denom == 0.0 or m2 == 0.0:
                            continue
                        ln_mean = np.log(m2 / denom)
                        ln_sd = np.sqrt(np.log(1.0 + VAR_i_j / m2))
                        factor = np.random.lognormal(ln_mean, ln_sd)
                    else:
                        adj_mu = m_i[j] + (tri_copy[r, j] / e_values[r])
                        m2 = adj_mu ** 2
                        denom = np.sqrt(m2 + VAR_i_j)
                        if denom == 0.0 or m2 == 0.0:
                            continue
                        ln_mean = np.log(m2 / denom)
                        ln_sd = np.sqrt(np.log(1.0 + VAR_i_j / m2))
                        factor = np.random.lognormal(ln_mean, ln_sd)

                    tri_copy[r, j + 1] = e_values[r] * factor + tri_copy[r, j]

            ult = np.sum(tri_copy[:, n_dev])
            results[batch_idx * batch_sim + i] = ult - ultimate_param_resrisk

    return results

