
    def triangle_forward_np(data, f, k_forward_start):
        data = data.copy()
        mm, nn = data.shape

        if len(f) > mm:
            pad_width = len(f) + 1 - nn
            if pad_width > 0:
                data = np.hstack((data, np.full((mm, pad_width), np.nan)))
        for j in range(k_forward_start - 1, len(f)):
            max_ind_row = max(0, mm - j - 1)
            for i in range(max_ind_row, mm):
                data[i, j + 1] = data[i, j] * f[j]

        cols_tmp = data.shape[1]

        tri_proj = np.empty((mm, cols_tmp + 1))
        tri_proj[:, 0] = data[:, 0]
        for r in range(mm):
            for c in range(cols_tmp):
                tri_proj[r, c + 1] = data[r, c]

        inc_proj = tri_proj[:, 1:] - tri_proj[:, :-1]
        inc_disc = np.empty_like(tri_proj)
        inc_disc[:, 0] = tri_proj[:, 0]
        for r in range(mm):
            for c in range(1, tri_proj.shape[1]):
                inc_disc[r, c] = inc_proj[r, c - 1]

        for rr in range(mm - 1, -1, -1):
            offset = mm - 1 - rr
            for cc in range(offset + 1, tri_proj.shape[1]):
                idx = cc - (offset + 1)
                if idx < len(discount_factors):
                    inc_disc[rr, cc] /= discount_factors[idx]

        cum_disc = inc_disc.copy()
        for r in range(mm):
            for c in range(1, tri_proj.shape[1]):
                cum_disc[r, c] += cum_disc[r, c - 1]

        ult_gross_disc = np.sum(cum_disc[:, -1])


        last_col = data[:, -1]
        result = np.nansum(ult_gross_disc)

        return result


    print(triangle_forward_np(data_paid_np, dev_arr, 0))
