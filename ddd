
from math import comb, sqrt
class AnalyzeDep2Request(BaseModel):
    triangle: List[List[Optional[float]]]
    ci: float = 0.95

class DensityPlot(BaseModel):
    curve:  list[tuple[float, float]]
    ci_area:list[tuple[float, float]]
    Z_stat: float
    Z_y:    float

class AnalyzeDep2Response(BaseModel):
    totals: dict[str, float]       # albo Dict[str, float]
    range:  dict[str, float]
    ci: float
    density_plot: Optional[DensityPlot] = None
# ------------------------------------------------------------------ #


# ------------------------------------------------------------------ #
#  LOGIKA                                                            #
# ------------------------------------------------------------------ #
def calendar_year_effect(triangle: List[List[Optional[float]]],
                         ci: float = 0.95) -> AnalyzeDep2Response:
    if not (0 < ci < 1):
        raise ValueError("ci must be between 0 and 1")

    tri = np.array(triangle, dtype=float)
    n_rows, n_cols = tri.shape

    cum_tri = np.nancumsum(tri, axis=1)

    ata = np.full((n_rows, n_cols - 1), np.nan)
    for i in range(n_rows):
        for j in range(n_cols - 1):
            if not np.isnan(cum_tri[i, j]) and not np.isnan(cum_tri[i, j + 1]) and cum_tri[i, j] != 0:
                ata[i, j] = cum_tri[i, j + 1] / cum_tri[i, j]

    col_medians = np.nanmedian(ata, axis=0)
    S_L = np.where(ata < col_medians, "S",
           np.where(ata > col_medians, "L", "*"))

    diags = [np.diag(np.fliplr(S_L)[:i, :i]) for i in range(2, n_rows)]

    Z_tot = E_tot = Var_tot = 0.0
    for d in diags:
        S_j = np.sum(d == "S")
        L_j = np.sum(d == "L")
        n_j = S_j + L_j
        m_j = (n_j - 1) // 2
        Z_j = min(S_j, L_j)
        Z_tot += Z_j

        if n_j > 0:
            E_j  = n_j / 2 - comb(n_j - 1, m_j) * n_j / 2 ** n_j
            Var_j = (n_j * (n_j - 1) / 4
                     - comb(n_j - 1, m_j) * n_j * (n_j - 1) / 2 ** n_j
                     + E_j - E_j ** 2)
        else:
            E_j = Var_j = 0
        E_tot  += E_j
        Var_tot += Var_j

    z_score = norm.ppf(ci + (1 - ci) / 2)
    rng_low = E_tot - z_score * sqrt(Var_tot)
    rng_up  = E_tot + z_score * sqrt(Var_tot)

    # --------- krzywa gęstości (jak w R‑owym plot) -----------------
    sd       = sqrt(Var_tot)
    x_seq    = np.linspace(E_tot - 4*sd, E_tot + 4*sd, 500)
    y_seq    = norm.pdf(x_seq, loc=E_tot, scale=sd)

    ci_x     = np.arange(rng_low, rng_up, 0.01)
    ci_y     = norm.pdf(ci_x, loc=E_tot, scale=sd)
    density  = {
        "curve":  list(zip(x_seq.tolist(), y_seq.tolist())),
        "ci_area":list(zip(ci_x.tolist(), ci_y.tolist())),
        "Z_stat": Z_tot,
        "Z_y":    norm.pdf(Z_tot, loc=E_tot, scale=sd)
    }
    # ---------------------------------------------------------------

    return AnalyzeDep2Response(
        totals = {
            "Z":      round(Z_tot, 4),
            "E[Z]":   round(E_tot, 4),   # ← klucz identyczny z nagłówkiem tabeli
            "Var[Z]": round(Var_tot, 4)
        },
        range  = {
            "Lower":  round(rng_low, 4),
            "Upper":  round(rng_up, 4)
        },
        ci = ci,
        density_plot = density
    )


# ------------------------------------------------------------------ #
#  ENDPOINT                                                          #
# ------------------------------------------------------------------ #
@app.post("/analyze-dep2", response_model=AnalyzeDep2Response)
def analyze_dep2(req: AnalyzeDep2Request):

    return calendar_year_effect(req.triangle, ci=req.ci)
