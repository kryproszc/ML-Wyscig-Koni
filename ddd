############ Deterministyczna

class PaidTriangleRequest(BaseModel):
    user_id: str
    paid_data_det: List[List[Union[str, int, float, None]]]
    weights: Optional[List[List[int]]] = None



class PaidCLRequest(BaseModel):
    user_id: str
    paid_data_det: List[List[Union[str, int, float, None]]]
    weights: List[List[int]]

@app.post("/calc/paid/train_devide_paid")
async def calc_paid_train_devide(payload: PaidTriangleRequest):
    data = {}
    headers = [x for x in range(len(payload.paid_data_det[0]))]
    for i, col in enumerate(headers):
        data[col] = []
        for row in payload.paid_data_det:
            value = row[i]
            try:
                num_value = float(value)
            except (ValueError, TypeError):
                num_value = None
            data[col].append(num_value)
    train_devide = TriangleCalculator.elementwise_division(data)
    print(pd.DataFrame(data).to_string())

    print(train_devide)
    train_devide_serializable = np.array(train_devide).tolist()

    print("train_devide")
    print(pd.DataFrame(train_devide_serializable).to_string())
    return {
        "train_devide": train_devide_serializable
    }


@app.post("/calc/paid/cl")
async def calc_paid_cl(payload: PaidCLRequest):
    paid_data = payload.paid_data_det
    weights = payload.weights
    print(pd.DataFrame(weights).to_string())
    print(pd.DataFrame(paid_data).to_string())

    data = {}
    headers = np.arange(len(paid_data[0]) )
 
    for i, col in enumerate(headers):
        data[col] = []
        for row in paid_data:
            value = row[i]
            try:
                num_value = float(value)
            except (ValueError, TypeError):
                num_value = None
            data[col].append(num_value)

    l_ij = pd.DataFrame(TriangleCalculator.elementwise_division(data))
    print(pd.DataFrame(l_ij).to_string())
    w_ij = pd.DataFrame(payload.weights)
    p_ij = pd.DataFrame(data)
    dev_j = TriangleCalculator.Dev_prem(p_ij,w_ij)

    print(dev_j)
    print("----")

    #sigmas = TriangleCalculator.calculate_sigma(p_ij, l_ij, w_ij, dev_j)
    ##print(sigmas[0])
    #print("----")
    #print(sigmas[1])
    #print("----")


    return {
        "message": "Odebrano dane i zastosowano wagi",
        "dev_j": list(dev_j),  # <- wa≈ºne! ≈ºeby by≈Ço JSON-serializowalne
    }


class SelectedDevJRequest(BaseModel):
    user_id: Optional[str] = None
    selected_dev_j: List[float]
    selected_indexes: Optional[List[int]] = None
    tail_values: Optional[List[float]] = None
    full_dev_j: List[float]  # <= NEW

@app.post("/calc/paid/selected_dev_j")
async def receive_selected_dev_j(payload: SelectedDevJRequest):
    full_ys = np.array(payload.full_dev_j, dtype=float)  # ca≈Ço≈õƒá
    xs = np.array(payload.selected_indexes, dtype=float) + 1
    ys = np.array(payload.selected_dev_j, dtype=float)

    curve_list = ["Exponential", "Weibull", "Power", "Inverse Power"]
    parameters_curve = calculator_det.parameters_curve_reservoir(xs=xs, ys=ys, lista_krzywych=curve_list)

    tail = int(payload.tail_values[0]) if payload.tail_values and len(payload.tail_values) > 0 else 0
    xs_sim = np.array([i + 1 for i in range(len(full_ys.tolist()) + tail)], dtype=float)
    simulation_results = calculator_det.sim_data_curve_rezerwy(xs_sim, curve_list, parameters_curve)

    f_curves_graph_real_choose = calculator_det.sim_data_curve_rezerwy(xs, curve_list, parameters_curve)
    r2_curves_df = calculator_det.r2_curves(f_curves_graph_real_choose, ys)
    print("r2_curves_df")
    print(r2_curves_df.to_dict())

    return  {
    "simulation_results": simulation_results.to_dict(),
    "r2_scores": r2_curves_df.to_dict()
}


####


# üß© Dane wsp√≥≈Çczynnik√≥w
class SaveVectorRequest(BaseModel):
    curve_name: Optional[str] = None
    coeffs: Optional[List[float]] = None
    volume: Optional[int] = None
    values: Optional[List[float]] = None
    final_dev_vector: Optional[List[float]] = None

# üß© G≈Ç√≥wna paczka: tr√≥jkƒÖt + wsp√≥≈Çczynniki
class SaveVectorPayload(BaseModel):
    paid_data_det: List[List[Optional[float]]]
    coeff_sets: List[SaveVectorRequest]

@app.post("/calc/paid/save_vector")
async def save_vector(payload: SaveVectorPayload):
    if len(payload.coeff_sets) != 2:
        raise HTTPException(status_code=400, detail="‚ùå Oczekiwano dok≈Çadnie 2 zestaw√≥w wsp√≥≈Çczynnik√≥w (A i B).")

    def extract_vector(p: SaveVectorRequest) -> List[float]:
        if p.curve_name and p.coeffs:
            return p.coeffs
        elif p.volume is not None and p.values:
            return p.values
        elif p.final_dev_vector:
            return p.final_dev_vector
        else:
            raise HTTPException(status_code=422, detail="‚ùå Nieprawid≈Çowy format jednego z obiekt√≥w.")

    try:
        wektor_a = extract_vector(payload.coeff_sets[0])
        wektor_b = extract_vector(payload.coeff_sets[1])
    except HTTPException as e:
        raise e

    df_triangle = pd.DataFrame(payload.paid_data_det).apply(pd.to_numeric, errors='coerce')
    df_triangle = df_triangle.drop(columns='AY', errors='ignore')
    df_proj_a = calculator_det.triangle_forward(df_triangle, wektor_a, 1)
    df_proj_b = calculator_det.triangle_forward(df_triangle, wektor_b, 1)
    last_values_a = df_proj_a.apply(lambda row: row[~row.isna()].iloc[-1], axis=1)
    last_values_b = df_proj_b.apply(lambda row: row[~row.isna()].iloc[-1], axis=1)
    diff = last_values_a - last_values_b
    percent_diff = ((last_values_a - last_values_b) / last_values_a) * 100
    df_comparison = pd.DataFrame({
        "Wiersz": range(len(df_proj_a)),
        "Projection A": last_values_a,
        "Projection B": last_values_b,
        "R√≥≈ºnica": diff.round(2),
        "R√≥≈ºnica %": percent_diff.round(2)
    })
    sum_a = last_values_a.sum()
    sum_b = last_values_b.sum()
    sum_diff = sum_a - sum_b
    sum_percent = (sum_diff / sum_a) * 100 if sum_a != 0 else None
    df_comparison.loc["Suma"] = {
        "Wiersz": "Suma",
        "Projection A": sum_a,
        "Projection B": sum_b,
        "R√≥≈ºnica": round(sum_diff, 2),
        "R√≥≈ºnica %": round(sum_percent, 2) if sum_percent is not None else None
    }
    return {
        "wektor_a": wektor_a,
        "wektor_b": wektor_b,
        "triangle_rows": len(payload.paid_data_det),
        "comparison": df_comparison.to_dict(orient="records")
    }
