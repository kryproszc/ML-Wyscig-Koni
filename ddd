import numpy as np
import pandas as pd
import time
from numba import njit

pd.options.display.float_format = '{:12.5e}'.format

# Wczytanie danych
wsp = pd.read_csv("wsp_csv.csv", sep=";", decimal=",")
dev = wsp.iloc[0, 0:59].to_numpy(dtype=np.float64)
sigma_j = wsp.iloc[1, 0:59].to_numpy(dtype=np.float64)
sd = wsp.iloc[2, 0:59].to_numpy(dtype=np.float64)

data_paid = pd.read_csv("data_input.csv", sep=";", decimal=",").iloc[:,1:]
data_paid_np = data_paid.to_numpy(dtype=np.float64)

data_wagi = pd.read_csv("wagi.csv", sep=";", decimal=",").iloc[:,1:]
data_wagi_np = data_wagi.to_numpy(dtype=np.float64)

def Dev_prem(data_paid_np: np.ndarray, data_wagi_np: np.ndarray):
    nn = data_paid_np.shape[1]

    licznik = np.array([
        np.sum(data_paid_np[:nn - j - 1, j + 1] * data_wagi_np[:nn - j - 1, j])
        for j in range(nn - 1)
    ])

    mianownik = np.array([
        np.sum(data_paid_np[:nn - j - 1, j] * data_wagi_np[:nn - j - 1, j])
        for j in range(nn - 1)
    ])

    with np.errstate(divide='ignore', invalid='ignore'):
        dev = np.divide(licznik, mianownik)
        dev[np.isnan(dev)] = 1  # gdy mianownik == 0

    return dev


def elementwise_division(data_paid_np: np.ndarray):
    # Zakładamy, że data_paid_np ma shape (n_rows, n_cols)
    prev = data_paid_np[:, :-1]
    curr = data_paid_np[:, 1:]

    with np.errstate(divide='ignore', invalid='ignore'):
        result = np.divide(curr, prev)
        result[~np.isfinite(result)] = 1

    return result

import numpy as np

def calculate_sigma(p_ij: np.ndarray, l_ij: np.ndarray, w_ij: np.ndarray, dev_j: np.ndarray):
    # Zakładamy: l_ij shape = (n_rows, n_cols), w_ij shape = (n_rows - 1, n_cols)
    n_rows, n_cols = l_ij.shape
    sigmas = []
    sds = []


    for j in range(n_cols):
        dev = dev_j[j]

        # Dopasuj długości przez obcięcie ostatniego wiersza
        w = w_ij[:, j]          # shape (n_rows - 1,)
        p = p_ij[:-1, j]        # shape (n_rows - 1,)
        l = l_ij[:-1, j]        # shape (n_rows - 1,)


        mask = ~np.isnan(w) & ~np.isnan(p) & ~np.isnan(l)

        w = w[mask]
        p = p[mask]
        l = l[mask]

        if len(w) > 1:
            diff = l - dev
            numerator = np.sum(w * p * diff ** 2)
            denominator = np.sum(w)
            denominator_sd = np.sum(w * p)
            sigma = np.sqrt(numerator / (denominator - 1)) if denominator > 1 else 0
            sd_val = sigma / np.sqrt(denominator_sd) if denominator_sd > 0 else 0
        else:
            sigma = 0
            sd_val = 0

        sigmas.append(sigma)
        sds.append(sd_val)

    return [sigmas, sds]


#dev_j = Dev_prem(data_paid_np,data_wagi_np)
#l_ij = elementwise_division(data_paid_np)
#sigma_j = calculate_sigma(data_paid_np,l_ij,data_wagi_np,dev_j)

##############
# Dopasowanie krzywych
##############

def choose_value_list(vec_input: np.ndarray, vec_wykluczenia: np.ndarray) -> np.ndarray:
    return vec_input[vec_wykluczenia - 1]

def wsp_w_k_sqr(f_input, se_factor, dopasowanie, n):
    if dopasowanie == 'factor_CL':
        w_k_sqr = 1 / np.sqrt(np.log(1 + (se_factor / (f_input - 1) ** 2)))
    elif dopasowanie == 'variance_CL':
        w_k_sqr = np.array([n - 1 - k for k in range(len(f_input))])
    elif dopasowanie == 'factor_P_to_I':
        w_k_sqr = np.ones(len(f_input) + 1)
    elif dopasowanie == 'variance_P_to_I':
        w_k_sqr = np.ones(len(f_input) + 1)
    elif dopasowanie == 'factor_LR':
        w_k_sqr = 1 / np.sqrt(np.log(1 + (se_factor / f_input ** 2)))
    elif dopasowanie == 'variance_LR':
        w_k_sqr = np.array([n - k for k in range(1, len(f_input) + 1)])
    else:
        raise ValueError(f"Nieznany tryb dopasowania: {dopasowanie}")

    return w_k_sqr

import numpy as np

def fit_curve(data_input, sd_input, x_k, dopasowanie, n):
    se_factor = np.array(sd_input[:len(data_input)]) ** 2
    w_k_sqr = wsp_w_k_sqr(np.array(data_input), se_factor, dopasowanie, n)

    data_input = np.array(data_input)

    if dopasowanie == 'factor_CL':
        factor_input = np.log(data_input - 1)
    elif dopasowanie == 'variance_CL':
        factor_input = np.log(data_input)  # tu data_input to sigma
    elif dopasowanie == 'factor_P_to_I':
        factor_input = np.log(1 - data_input)
    elif dopasowanie == 'variance_P_to_I':
        factor_input = np.log(data_input)
    elif dopasowanie in ('factor_LR', 'variance_LR'):
        factor_input = np.log(data_input)
    else:
        raise ValueError(f"Nieznane dopasowanie: {dopasowanie}")

    x_k = np.array(x_k)
    factor_input = np.array(factor_input)

    A = np.sum(w_k_sqr)
    A_x = np.sum(w_k_sqr * x_k)
    A_xx = np.sum(w_k_sqr * x_k**2)
    A_y = np.sum(w_k_sqr * factor_input)
    A_xy = np.sum(w_k_sqr * x_k * factor_input)

    Delta = A * A_xx - A_x**2

    a = (A * A_xy - A_x * A_y) / Delta
    b = (A_xx * A_y - A_x * A_xy) / Delta

    return [a, b]

import numpy as np

def wspolczynnik_reg(a, b, k_start, k_stop, dopasowanie):
    k_values = np.arange(k_start, k_stop + 1)
    exponent = np.exp(a * k_values + b)

    if dopasowanie == 'factor_CL':
        wartosci_reg = 1 + exponent
    elif dopasowanie in ('variance_CL', 'variance_P_to_I', 'factor_LR', 'variance_LR'):
        wartosci_reg = exponent
    elif dopasowanie == 'factor_P_to_I':
        wartosci_reg = 1 - exponent
    else:
        raise ValueError(f"Nieznane dopasowanie: {dopasowanie}")

    return wartosci_reg





#dev_j = Dev_prem(data_paid_np,data_wagi_np)
#l_ij = elementwise_division(data_paid_np)
#sigma_j = calculate_sigma(data_paid_np,l_ij,data_wagi_np,dev_j)


#dev_choose = choose_value_list(dev_j,np.array([2,3,4,5,6,7,8]))
#sd_choose = choose_value_list(np.array(sigma_j[1]), np.array([2, 3, 4, 5, 6, 7,8]))

#sd_choose_sqrt = np.array(sd_choose)
#a, b = fit_curve(dev_choose, sd_choose_sqrt, np.array([2,3,4,5,6,7,8]), 'factor_CL', -99)
#Poz_CL = 8
#il_ogon = 33
#vec_output = np.concatenate([
#    dev_j[:Poz_CL],
#    wspolczynnik_reg(a, b, Poz_CL + 1, len(dev_j) + il_ogon - 1, 'factor_CL')
#])

import numpy as np

def triangle_forward_one_np(triangle_input: np.ndarray, f: np.ndarray, k_forward_start: int) -> np.ndarray:

    mm, nn = triangle_input.shape
    triangle_extended = np.copy(triangle_input)

    # Dodaj kolumny jeśli potrzebne
    required_cols = len(f) + 1  # +1 bo ostatni rozwój jest do j+1
    if triangle_extended.shape[1] < required_cols:
        extra_cols = required_cols - triangle_extended.shape[1]
        triangle_extended = np.hstack([triangle_extended, np.zeros((mm, extra_cols))])

    for j in range(k_forward_start - 1, len(f)):
        if j + 1 >= triangle_extended.shape[1]:
            print(f"❌ Próbujesz zapisać do kolumny {j + 1}, która nie istnieje!")
            continue

        max_ind_row = max(0, mm - j - 1)
        for i in range(max_ind_row, mm):
            triangle_extended[i, j + 1] = triangle_extended[i, j] * f[j]

    return triangle_extended




############
def stochastic_triangle_forward_numba_batched(data_paid, sigma_j, dev, sd, wagi_trimmed, wykluczenia, Poz_CL, il_ogon,
                                              sim_total=1000, batch_sim=1000,
                                              ultimate_param_resrisk=0,
                                              main_seed=202260011):
    mm, n_cols_orig = data_paid.shape
    n_dev = len(dev)
    results = np.zeros(sim_total)
    results_one = np.zeros(sim_total)
    discount_factors = np.array([
        1.0301, 1.0991, 1.1749, 1.2562, 1.3416, 1.4310, 1.5250, 1.6243,
        1.7304, 1.8439, 1.9630, 2.0852, 2.2095, 2.3360, 2.4649, 2.5960,
        2.7293, 2.8649, 3.0027, 3.1432, 3.2863, 3.4322, 3.5811, 3.7328,
        3.8876, 4.0467, 4.2093, 4.3755, 4.5462, 4.7211, 4.9004, 5.0851,
        5.2750, 5.4703, 5.6716, 5.8782, 6.0916, 6.3111, 6.5372, 6.7715,
        7.0135, 7.2622, 7.5179, 7.7826, 8.0569, 8.3398, 8.6318, 8.9333,
        9.2450, 9.5673, 9.9010, 10.2467, 10.6026, 10.9719, 11.3523, 11.7444,
        12.1520, 12.5726, 13.0104, 13.4628, 13.9263, 14.4053, 14.9050, 15.4220,
        15.9525, 16.5016, 17.0757, 17.6651, 18.2702, 18.9037
    ])
    num_batches = sim_total // batch_sim

    for batch in range(num_batches):
        seed = main_seed + batch
        mu_part = np.empty((batch_sim, n_dev))
        sigma_part = np.empty((batch_sim, n_dev))
        np.random.seed(seed)
        for j in range(n_dev):
            mu_part[:, j] = np.random.normal(loc=dev[j], scale=sd[j], size=batch_sim)
            df = max(1, mm - j - 1)
            chi_list = np.random.chisquare(df, size=batch_sim)
            for s in range(batch_sim):
                sigma_part[s, j] = (np.floor(chi_list[s]) * sigma_j[j]) / df

        for i in range(batch_sim):
            m_i = mu_part[i, :]
            sigma_i = sigma_part[i, :]
            data_paid_copy = np.copy(data_paid).astype(np.float64)
            new_triangle = np.copy(data_paid).astype(np.float64)
            wagi_trimmed_np = np.copy(wagi_trimmed).astype(np.float64)
            n_cols_current = data_paid_copy.shape[1]
            if n_cols_current < n_dev + 1:
                extra_cols = (n_dev + 1) - n_cols_current
                data_paid_copy = np.hstack([data_paid_copy, np.zeros((mm, extra_cols))])
                new_triangle = np.hstack([new_triangle, np.zeros((mm, extra_cols))])
                n_cols_current = data_paid_copy.shape[1]
            for j in range(n_dev):
                max_ind_row = max(1, mm - j)
                for r in range(max_ind_row - 1, mm):
                    base_val = data_paid_copy[r, j]
                    if base_val == 0:
                        continue
                    var_ij = sigma_i[j] / base_val
                    m_sq = m_i[j] * m_i[j]
                    denom = np.sqrt(m_sq + var_ij)
                    if denom == 0.0 or m_sq == 0.0:
                        continue
                    lmean = np.log(m_sq / denom)
                    lstdev = np.sqrt(np.log(1 + (var_ij / m_sq)))
                    cl_ij = np.random.lognormal(mean=lmean, sigma=lstdev)
                    factor = base_val * cl_ij
                    data_paid_copy[r, j + 1] = factor
                    if r == mm - j - 1:
                        new_triangle[r, j + 1] = factor

            triangle_simulated = new_triangle[:, 1:(n_cols_orig+1)]
            dev_j = Dev_prem(triangle_simulated, wagi_trimmed_np)
            l_ij = elementwise_division(triangle_simulated)
            sigma_all = calculate_sigma(triangle_simulated, l_ij, wagi_trimmed_np, dev_j)
            sd_sim = np.array(sigma_all[1])

            dev_choose = choose_value_list(dev_j, np.array(wykluczenia))
            sd_choose = choose_value_list(sd_sim, np.array(wykluczenia))

            sd_choose_sqrt = np.array(sd_choose)
            a, b = fit_curve(dev_choose, sd_choose_sqrt, np.array(wykluczenia), 'factor_CL', -99)
            a = float(a)
            b = float(b)

            vec_output = np.concatenate([
                dev_j[:Poz_CL],
                wspolczynnik_reg(a, b, Poz_CL + 1, len(dev_j) + il_ogon - 1, 'factor_CL')
            ])
            proj_trian_one = triangle_forward_one_np(triangle_simulated, vec_output, 1)
            proj_trian_one = np.hstack([data_paid_copy[:, [0]], proj_trian_one])
            inkrementalne_proj = np.diff(proj_trian_one, axis=1)
            inkrementalne_dysk = np.copy(inkrementalne_proj)
            inkrementalne_dysk = np.hstack([data_paid_copy[:, [0]], inkrementalne_dysk])

            rows, cols = inkrementalne_dysk.shape
            for ii in range(rows - 1, -1, -1):
                offset = rows - 1 - ii
                for j in range(offset + 1, cols):
                    discount_index = j - (offset + 1)
                    if discount_index < len(discount_factors):
                        inkrementalne_dysk[ii, j] /= discount_factors[discount_index+1]
            inkrementalne_dysk_spec = np.copy(inkrementalne_dysk)


            for col in range(1, inkrementalne_dysk.shape[1]):
                inkrementalne_dysk_spec[:, col] = np.sum(inkrementalne_dysk[:, :col + 1], axis=1)

            u_i_one = inkrementalne_dysk_spec[:, n_cols_current - 1]
            u_i = data_paid_copy[:, n_cols_current - 1]

            results[batch * batch_sim + i] = np.sum(u_i_one) - ultimate_param_resrisk

    return results


# Parametry
sim_total = 1000
#4075793358
#3894728405
#4232149669.5967

ultimate_base = 4075793358
factor = 1.1392
wykluczenia = [2,3,4,5,6,7,8]
Poz_CL = 8
il_ogon = 42
# Uruchomienie
start = time.time()


#####################

result = stochastic_triangle_forward_numba_batched(
    data_paid=data_paid_np,
    sigma_j=sigma_j,
    dev=dev,
    sd=sd,
    wagi_trimmed = data_wagi_np,
    wykluczenia = wykluczenia,
    Poz_CL = Poz_CL,
    il_ogon =il_ogon,
    sim_total=sim_total,
    batch_sim=1,
    ultimate_param_resrisk=0,
    main_seed=202260011
)

end = time.time()

print(f"\n⏱ Czas wykonania: {end - start:.2f} sekund")

# Wyniki i analiza
results_cale = factor * (result - ultimate_base)
print(f"📊 Median: {np.median(results_cale):,.2f}")
print(f"📊 sd: {np.std(results_cale):,.2f}")

for q in [0.75,0.9,0.95,0.99,0.995]:
    print(f"Quantile {q}: {np.quantile(results_cale, q):,.2f}")
print(f"Mean: {np.mean(results_cale):,.2f}")
print(f"Difference (Quantile - Mean): {np.quantile(results_cale, 0.995) - np.mean(results_cale):,.2f}")
