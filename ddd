

class SaveVectorRequest(BaseModel):
    curve_name:        Optional[str]        = None   # symulowana krzywa CL
    coeffs:            Optional[List[float]] = None  # ⬆ jej współczynniki
    volume:            Optional[int]         = None  # dev_j z konkretnego volume
    values:            Optional[List[float]] = None  # ⬆ jego wektor dev_j
    final_dev_vector:  Optional[List[float]] = None  # gotowy dev_final / combined


# ──────────────────────────────────────────────────────────────────────────────
#  2. Cały payload: trójkąt incurred + dokładnie 2 zestawy współczynników
# ──────────────────────────────────────────────────────────────────────────────
class SaveVectorPayload(BaseModel):
    incurred_data_det: List[List[Optional[float]]]
    coeff_sets:        List[SaveVectorRequest]


# ──────────────────────────────────────────────────────────────────────────────
#  3. Pomocnicza funkcja – wyciąga wektor z SaveVectorRequest
# ──────────────────────────────────────────────────────────────────────────────
def _extract_vector(p: SaveVectorRequest) -> List[float]:
    if p.curve_name and p.coeffs:
        return p.coeffs
    if p.volume is not None and p.values:
        return p.values
    if p.final_dev_vector:
        return p.final_dev_vector
    raise HTTPException(
        status_code=422,
        detail="❌ Nieprawidłowy format jednego z obiektów (brak danych wektora).",
    )


# ──────────────────────────────────────────────────────────────────────────────
#  4. Endpoint  POST /calc/incurred/save_vector
# ──────────────────────────────────────────────────────────────────────────────
@app.post("/calc/incurred/save_vector")
async def save_vector_incurred(payload: SaveVectorPayload):
    # 4.a – walidacja liczby zestawów
    if len(payload.coeff_sets) != 2:
        raise HTTPException(
            status_code=400,
            detail="❌ Oczekiwano dokładnie 2 zestawów współczynników (A i B).",
        )

    # 4.b – wyciągamy dwa wektory
    vector_a = _extract_vector(payload.coeff_sets[0])
    vector_b = _extract_vector(payload.coeff_sets[1])

    # 4.c – budujemy DataFrame z trójkąta incurred
    df_triangle = (
        pd.DataFrame(payload.incurred_data_det)
        .apply(pd.to_numeric, errors="coerce")
        .drop(columns="AY", errors="ignore")          # jeśli nagłówek AY istnieje
    )

    # 4.d – projekcje (używamy Twojej istniejącej util‑funkcji)
    df_proj_a = calculator_det.triangle_forward(df_triangle, vector_a, 1)
    df_proj_b = calculator_det.triangle_forward(df_triangle, vector_b, 1)

    # 4.e – ostatnie nie‑NaN‑y w wierszach
    last_a = df_proj_a.apply(lambda r: r.dropna().iloc[-1], axis=1)
    last_b = df_proj_b.apply(lambda r: r.dropna().iloc[-1], axis=1)

    diff_abs = last_a - last_b
    diff_pct = (diff_abs / last_a.replace({0: pd.NA})) * 100

    # 4.f – tabela porównania
    df_cmp = pd.DataFrame(
        {
            "Wiersz":        range(len(df_proj_a)),
            "Projection A":  last_a.round(2),
            "Projection B":  last_b.round(2),
            "Różnica":       diff_abs.round(2),
            "Różnica %":     diff_pct.round(2),
        }
    )

    # wiersz SUMA
    sum_a, sum_b = last_a.sum(), last_b.sum()
    sum_diff     = sum_a - sum_b
    sum_pct      = (sum_diff / sum_a * 100) if sum_a != 0 else None

    df_cmp.loc["Suma"] = {
        "Wiersz":       "Suma",
        "Projection A": round(sum_a, 2),
        "Projection B": round(sum_b, 2),
        "Różnica":      round(sum_diff, 2),
        "Różnica %":    round(sum_pct, 2) if sum_pct is not None else None,
    }

    # 4.g – zwrot dla front‑endu
    return {
        "wektor_a":      vector_a,
        "wektor_b":      vector_b,
        "triangle_rows": len(payload.incurred_data_det),
        "comparison":    df_cmp.to_dict(orient="records"),
    }
