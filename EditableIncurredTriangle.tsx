paid
array([[11393557.39, 12814950.58, 12980742.69, 13076731.19, 13095105.09,
        13243694.11, 13243839.84, 13241976.53, 13242175.03, 13242175.03,
        13242175.03, 13242175.03, 13246993.03, 13247479.07, 13248385.66,
        13249813.67, 13250706.39, 13251130.47, 13251197.51, 13251197.51],
       [3405888.1399999997, 4032964.6299999994, 4078965.5099999993,
        4142735.9899999993, 4141525.7099999995, 4176561.1599999997,
        4176895.0099999993, 4176597.4099999997, 4254219.649999998,
        4255576.309999998, 4311525.269999998, 4311137.239999997,
        4311117.139999997, 4311117.139999997, 4311117.139999997,
        4311117.139999997, 4311117.139999997, 4311117.139999997,
        4311117.139999997, <NA>],
       [4255011.56, 5318357.58, 5206452.829999997, 5166282.059999998,
        5167889.449999998, 5180254.449999999, 5223960.719999999,
        5233183.62, 5235448.609999999, 5235671.619999999,
        5235671.619999999, 5235682.1899999995, 5235682.1899999995,
        5235682.1899999995, 5235682.1899999995, 5235682.1899999995,
        5235682.1899999995, 5235682.1899999995, <NA>, <NA>],
       [5553204.539999999, 6902426.139999999, 6920101.49,
        7111465.130000001, 7093413.770000001, 7088376.710000002,
        7083581.680000003, 7081446.330000004, 7075176.150000004,
        7064687.010000003, 7065107.030000002, 7065107.030000002,
        7065107.030000002, 7065107.030000002, 7065107.030000002,
        7065107.030000002, 7065107.030000002, <NA>, <NA>, <NA>],
       [8292673.55, 10308187.869999997, 10208960.959999999,
        10174210.409999998, 10174971.139999999, 10260394.669999998,
        10246313.869999997, 10245789.859999996, 10245540.859999996,
        10245150.11, 10245062.959999997, 10245663.199999997,
        10246243.669999996, 10246243.669999996, 10246243.669999996,
        10246243.669999996, <NA>, <NA>, <NA>, <NA>],
       [13244735.03, 15284101.680000003, 15280980.860000003,
        15262918.700000009, 15274326.340000007, 15426991.64000001,
        15426673.10000001, 15428200.53000001, 15428587.290000012,
        15428763.510000013, 15428843.800000012, 15428843.800000012,
        15428843.800000012, 15428843.800000012, 15428845.700000012, <NA>,
        <NA>, <NA>, <NA>, <NA>],
       [14638730.350000001, 17906664.499999996, 17734407.929999996,
        17437025.699999996, 17480811.97, 17477392.649999995,
        17473852.639999993, 17474846.619999997, 17476620.91, 17474285.67,
        17483824.07, 17768642.419999998, 17768668.029999997,
        17768671.029999997, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [28702377.81, 32606187.189999998, 32244746.409999993,
        32106278.979999997, 32093314.529999997, 32285568.39,
        32274154.780000005, 32277544.980000004, 32277598.720000003,
        32277598.720000003, 32277615.720000003, 32277615.720000003,
        32277618.720000003, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [77190968.8, 99007354.82999997, 102665784.70999998,
        104778411.76999998, 106000378.59049998, 106722515.47049996,
        107227750.26049998, 107279335.57049999, 107292838.2505,
        107295549.77049999, 107296830.48049998, 107296597.52049997, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [34420181.33, 37786118.46000001, 37960338.769999996,
        38292578.87999999, 39077113.399999976, 39195736.68999998,
        39274500.70999998, 39396966.56999998, 39575761.94999998,
        39575562.02999999, 39575574.47999999, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>],
       [36691062.86, 41391677.900000006, 41688243.8905,
        42180098.300500005, 42595392.8205, 42861749.97049999,
        43002166.5705, 43034931.450500004, 43094795.23049999,
        43100269.85049998, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>],
       [43585513.76, 48522245.35200001, 48675912.86200002,
        49123408.09200002, 49478029.79200001, 49586390.412000015,
        49630440.21200001, 50341926.92200001, 50383049.23200003, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [35567150.852, 39670631.752, 39741520.782, 39928210.26199999,
        40023435.89199999, 40106045.37199999, 40173372.522,
        40372575.502000004, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>],
       [40830397.25, 46802260.51999999, 46972558.94, 47606213.970000006,
        47719762.11000001, 47724128.27, 47724756.51, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [47504468.21, 54126394.379999995, 54233209.029999994,
        54920890.67999999, 55015054.78, 55056797.02000001, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>],
       [55508785.06, 64315725.92, 64360060.32, 64577585.57999999,
        64944499.05, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [47457779.64, 54610308.04000002, 55112816.36000002,
        55615998.43000002, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [53496567.4, 59961062.87, 60333576.93000001, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>],
       [61904536.42, 71235835.20000002, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>],
       [88699579.20999998, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>]], dtype=object)

inc
array([[13302149.540000001, 13073089.4, 13031505.62, 13121149.59,
        13135277.4, 13256104.809999999, 13256152.65, 13249844.719999999,
        13250043.219999999, 13250043.219999999, 13242175.03, 13242175.03,
        13246993.03, 13247479.07, 13248385.66, 13249813.67, 13250706.39,
        13251130.47, 13251197.51, 13251197.51],
       [4451167.81, 4239947.709999999, 4183810.059999999,
        4156449.7999999993, 4259566.649999999, 4294602.1,
        4294935.949999999, 4294638.35, 4448399.289999997,
        4439715.009999998, 4458130.959999998, 4311137.239999997,
        4311117.139999997, 4311117.139999997, 4311117.139999997,
        4311117.139999997, 4311117.139999997, 4311117.139999997,
        4311117.139999997, <NA>],
       [6181472.09, 5452365.65, 5296925.0299999975, 5384929.189999998,
        5377451.6099999985, 5232856.449999999, 5229560.719999999,
        5233183.62, 5235448.609999999, 5235671.619999999,
        5235671.619999999, 5235682.1899999995, 5235682.1899999995,
        5235682.1899999995, 5235682.1899999995, 5235682.1899999995,
        5235682.1899999995, 5235682.1899999995, <NA>, <NA>],
       [7277650.029999999, 7224263.799999999, 7376242.2,
        7249556.550000001, 7205027.700000001, 7088376.710000002,
        7083581.680000003, 7081446.330000004, 7075176.150000004,
        7064687.010000003, 7065107.030000002, 7065107.030000002,
        7065107.030000002, 7065107.030000002, 7065107.030000002,
        7065107.030000002, 7065107.030000002, <NA>, <NA>, <NA>],
       [10328768.68, 10406506.909999996, 10261032.899999999,
        10259227.019999998, 10262556.339999998, 10273398.429999998,
        10251913.869999997, 10251389.859999996, 10245540.859999996,
        10245150.11, 10245062.959999997, 10245663.199999997,
        10246243.669999996, 10246243.669999996, 10246243.669999996,
        10246243.669999996, <NA>, <NA>, <NA>, <NA>],
       [15264816.93, 15374402.820000004, 15329060.060000002,
        15374396.490000008, 15360157.760000007, 15466322.84000001,
        15466004.30000001, 15428200.53000001, 15428587.290000012,
        15428763.510000013, 15428843.800000012, 15428843.800000012,
        15428843.800000012, 15428843.800000012, 15428845.700000012, <NA>,
        <NA>, <NA>, <NA>, <NA>],
       [17620644.53, 17994639.199999996, 17828113.079999994,
        17486702.189999994, 17481979.77, 17477810.449999996,
        17474270.439999994, 17659864.419999998, 17661220.91, 17658885.67,
        17668424.07, 17768642.419999998, 17768668.029999997,
        17768671.029999997, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [32322436.79, 32856682.81, 32562654.529999994, 32333398.619999997,
        32362139.349999998, 32304784.39, 32293370.780000005,
        32277544.980000004, 32277598.720000003, 32277598.720000003,
        32277615.720000003, 32277615.720000003, 32277618.720000003, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [84888714.28, 101956358.36999997, 105322238.57999998,
        106806827.45999998, 106945518.73049998, 107347678.63049996,
        107372072.83049998, 107329325.91049999, 107310402.7905,
        107313114.3105, 107346030.48049998, 107349597.52049997, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [38101878.78, 38544140.48000001, 38905234.3, 39513836.53999999,
        39927469.299999975, 39734443.929999985, 39686683.28999998,
        39692109.56999998, 39575761.94999998, 39575562.02999999,
        39575574.47999999, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>],
       [44121656.58, 42550485.29000001, 43201367.7905,
        43670616.950500004, 43431868.9905, 43244679.72049999,
        43251647.0605, 43090302.450500004, 43130765.23049999,
        43136239.85049998, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>],
       [50329989.599999994, 50251421.78200001, 50821879.622000016,
        50662928.88200002, 50902776.20200001, 50899407.842000015,
        50836086.272000015, 50623926.92200001, 50419049.23200003, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [41012802.192, 40289179.721999995, 40602074.412,
        40222424.42199998, 40298391.19199999, 40301876.491999984,
        40398973.522, 40457175.502000004, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [48387942.15, 48693467.58999999, 48281219.339999996,
        48743621.080000006, 48668341.11000001, 48640103.27, 48624906.51,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>],
       [54833721.29, 56084426.63999999, 56285214.8, 56213979.68999999,
        56068643.72, 56076141.37000001, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [65347290.39, 68228165.94, 67348202.55, 67587018.91999999,
        67788759.39, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [55221696.94, 56100444.28000002, 55910448.69000002,
        56703405.33000002, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>],
       [61286770.83, 60410836.08, 60945107.67000001, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>],
       [71929789.52, 71706782.08000001, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>],
       [101390176.55999997, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>, <NA>,
        <NA>]], dtype=object)




###############
data_incurred_pd = pd.DataFrame(triangle_incurred_2)
triangle_paid_infl_pd = pd.DataFrame(triangle_paid)
data_wagi_pi_pd = pd.DataFrame(data_wagi_pi)
data_incurred_pd = data_incurred_pd.copy()

r_j = yh.wspolczynnik_r(triangle_paid_infl_pd,data_incurred_pd,data_wagi_pi_pd)

# wspolczynniki do symulacyjnej

r_i_j = yh.wspolczynnik_r_i_j(triangle_paid_infl_pd,data_incurred_pd)
var_j = yh.wspolczynnik_var_j(data_incurred_pd,r_i_j,r_j,data_wagi_pi_pd)
res_i_j = wspolczynnik_res_i_j(r_i_j,r_j,var_j,data_incurred_pd,data_wagi_pi_pd)
lambda_cor = lambda_cerrelation(res_i_j)


  def wspolczynnik_r(self, d_paid, d_claim,weights):
        wspol = []
        for i in range(d_paid.shape[1]):
            licznik =  [(x*float(y)) for x,y in zip(d_paid.iloc[:(d_paid.shape[0]-i),i],weights.iloc[:(d_paid.shape[0]-i),i])]
            mianownik = [float(y)*z for y,z in zip(d_claim.iloc[:(d_paid.shape[0] - i), i],weights.iloc[:(d_paid.shape[0] - i), i])]
            if(np.sum(mianownik)>0):
                wspol.append(np.sum(licznik)/np.sum(mianownik))
            else:
                wspol.append(1)
        return(wspol)
#6.3.2
    def wspolczynnik_r_i_j(self,dd_paid,dd_claim):
        mm = dd_paid.shape[0]
        nn = dd_paid.shape[1]
        l_triangl = pd.DataFrame(0, columns=dd_paid.columns, index=dd_paid.index,dtype="Float64")
        for j in range(nn):
            for i in range(mm - j):
                if(dd_claim.iloc[i, j]!=0):
                    l_triangl.iloc[i, j] = (dd_paid.iloc[i, j]/dd_claim.iloc[i, j])
                else:
                    l_triangl.iloc[i, j] = 0.0001
        return (l_triangl)
    def kwadrat_roznicy(self,data_frame, vector):
        mm = data_frame.shape[0]
        nn = data_frame.shape[1]
        l_triangl = pd.DataFrame(0, columns=data_frame.columns, index=data_frame.index,dtype="Float64")
        for j in range(nn-1):
            for i in range(mm - j):
                l_triangl.iloc[i, j] = (data_frame.iloc[i, j] - vector[j])**2
        return (l_triangl)
    def wspolczynnik_var_j(self,data_claim,wspo_r_i_j,wspo_r_j,weights):
        mm = data_claim.shape[0]
        nn = data_claim.shape[1]
        var_j = []
        roznica_r_i_j = self.kwadrat_roznicy(wspo_r_i_j,wspo_r_j)
        for j in range(nn):
            var_j_pom = []
            for i in range(mm - j):
                var_j_pom.append(data_claim.iloc[i,j]*roznica_r_i_j.iloc[i,j]*weights.iloc[i,j])
            if (nn-j)==1:
                if (var_j[len(var_j) - 2]>0):
                    mianownik_pom = var_j[len(var_j) - 2]
                else:
                    mianownik_pom = 1
                s_min = np.min([var_j[len(var_j) - 1], var_j[len(var_j) - 2],((var_j[len(var_j) - 1]) ** 2)/mianownik_pom])
                var_j.append(s_min)
            else:
                if(np.sum(weights.iloc[:,j])-1>0):
                    var_j.append((np.sum(var_j_pom))/(np.sum(weights.iloc[:,j])-1))
                else:
                    var_j.append((np.sum(var_j_pom))/1)
        return(var_j)
    def wspolczynnik_res_i_j(self,wspo_r_i_j,wspo_r_j,wspo_var_j,data_frame,weights):
        mm = data_frame.shape[0]
        nn = data_frame.shape[1]
        l_triangl = pd.DataFrame(0, columns=data_frame.columns, index=data_frame.index,dtype="Float64")
        for j in range(nn):
            for i in range(mm - j):
                licznik = (wspo_r_i_j.iloc[i,j] - wspo_r_j[j])*weights.iloc[i,j]
                mianownik = np.sqrt(wspo_var_j[j]/data_frame.iloc[i,j])
                if (mianownik>0):
                    l_triangl.iloc[i, j] = licznik/mianownik
                else:
                    l_triangl.iloc[i, j] = 0
        return (l_triangl)

def lambda_cerrelation(triangle_res):
    mm = triangle_res.shape[0]
    nn = triangle_res.shape[1]
    col_list = []
    col_kwadrat = []
    for i in range(mm-1):
        for j in range(nn-1-i):
            col_list.append(triangle_res.iloc[i,j]*triangle_res.iloc[i,j+1])
            col_kwadrat.append((triangle_res.iloc[i,j])**2)
    lambda_cor = np.sum(col_list)/np.sum(col_kwadrat)
    return(lambda_cor)


def choose_value_list_np(vec_input, vec_wykluczenia, a, b):
    count = 0
    for k in range(len(vec_wykluczenia)):
        idx = vec_wykluczenia[k] - 1
        val = vec_input[idx]
        if a < val < b:
            count += 1

    out_vals = np.empty(count)
    out_inds = np.empty(count, dtype=np.int64)

    pos = 0
    for k in range(len(vec_wykluczenia)):
        idx = vec_wykluczenia[k] - 1
        val = vec_input[idx]
        if a < val < b:
            out_vals[pos] = val
            out_inds[pos] = idx
            pos += 1

    return out_vals, out_inds

def wspolczynnik_res_i_j(wspo_r_i_j,wspo_r_j,wspo_var_j,data_frame,weights):
    mm = data_frame.shape[0]
    nn = data_frame.shape[1]
    l_triangl = pd.DataFrame(0, columns=data_frame.columns, index=data_frame.index,dtype="Float64")
    for j in range(nn):
        for i in range(mm - j):
            licznik = (wspo_r_i_j.iloc[i,j] - wspo_r_j[j])*weights.iloc[i,j]
            mianownik = np.sqrt(wspo_var_j[j]/data_frame.iloc[i,j])
            if (mianownik>0):
                l_triangl.iloc[i, j] = licznik/mianownik
            else:
                l_triangl.iloc[i, j] = 0
    return (l_triangl)




######################### deterministtyczny

def triangle_forward_np_p_i(triangle_data: np.ndarray,triangle_paid_infl: np.ndarray, f: np.ndarray,rj: np.ndarray, discount_factors,net_to_gross) -> np.ndarray:
    mm, nn = triangle_data.shape
    n_steps = len(f)
    required_cols = n_steps + 1

    base_col = triangle_paid_infl[:, 0].copy()
    if nn < required_cols:
        extra_cols = required_cols - nn
        triangle_extended = np.full((mm, required_cols), np.nan)
        triangle_extended[:, :nn] = triangle_data
        triangle_extended_paid = np.full((mm, required_cols), np.nan)
        triangle_extended_paid[:, :nn] = triangle_paid_infl
    else:
        triangle_extended = triangle_data.copy()
    for j in range(n_steps):
        max_ind_row = max(0, mm - j - 1)
        for i in range(max_ind_row, mm):
            if np.isnan(triangle_extended[i, j]):
                continue
            triangle_extended[i, j + 1] = triangle_extended[i, j] * f[j]
            triangle_extended_paid[i, j + 1] = triangle_extended[i, j + 1]*rj[j+1]
    cols_tmp = triangle_extended_paid.shape[1]
    tri_proj = np.full((mm, cols_tmp + 1), np.nan)
    tri_proj[:, 0] = base_col
    tri_proj[:, 1:] = triangle_extended_paid
    inc_proj = tri_proj[:, 1:] - tri_proj[:, :-1]
    inc_proj[:, 0] = base_col
    for rr in range(mm - 1, -1, -1):
        offset = mm - 1 - rr
        for cc in range(offset + 1, inc_proj.shape[1]):
            idx = cc - (offset + 1)
            if idx < len(discount_factors) and not np.isnan(inc_proj[rr, cc]):
                inc_proj[rr, cc] /= discount_factors[idx]
    total_disc = np.sum(np.nansum(inc_proj, axis=1))

    cum_trian = np.nansum(inc_proj, axis=1)
    ult_net_disc = 0

    latest = vector_reverse_diagonal(triangle_data)
    #ult_net_disc = total_disc*0.8841
    for i_net in range(len(latest)):
        ult_net_disc += cum_trian[i_net] * net_to_gross[i_net]
#    return [np.sum(triangle_extended_paid[:,-1]),total_disc,ult_net_disc]
    #net_to_gross[i_net]
    return [np.sum(triangle_extended_paid[:,-1]),total_disc,ult_net_disc]


##### deterministyczne obliczenia

###########################


import numpy as np
from numba import njit


@njit
def Dev_prem(data_paid: np.ndarray, wagi: np.ndarray) -> np.ndarray:
    n_row, n_col = data_paid.shape
    dev = np.empty(n_col - 1)
    for j in range(n_col - 1):
        num = den = 0.0
        for i in range(n_row):
            val_curr = data_paid[i, j]
            val_next = data_paid[i, j + 1]
            w = wagi[i, j]
            if not (np.isnan(val_next)):
                num += val_next * w
                den += val_curr * w
        dev[j] = num / den if den != 0.0 else 1.0
    return dev


@njit
def elementwise_division(data_paid: np.ndarray) -> np.ndarray:

    n_rows, n_cols = data_paid.shape
    out = np.empty((n_rows, n_cols - 1))
    for i in range(n_rows):
        for j in range(n_cols - 1):
            a = data_paid[i, j]
            b = data_paid[i, j + 1]
            if a != 0.0 and not np.isnan(b):
                val = b / a
                out[i, j] = val if np.isfinite(val) else 1.0
            else:
                out[i, j] = 1.0
    return out


@njit
def calculate_sigma(p_ij, l_ij, w_ij, dev_j):
    n_rows, n_cols = l_ij.shape
    sigmas = np.empty(n_cols)
    sds = np.empty(n_cols)
    for j in range(n_cols):
        dev = dev_j[j]
        num = den = den_sd = 0.0
        cnt = 0
        for i in range(n_rows):
            w = w_ij[i, j]
            p = p_ij[i, j]
            l = l_ij[i, j]
            if not (np.isnan(w)):
                diff = l - dev
                num += w * p * diff * diff
                den += w
                den_sd += w * p
                cnt += 1
        if  den > 1.0 and num > 0:
            sigma = num / (den - 1.0)
        else:
            sigma = 0
        sd_val = sigma / den_sd if den_sd > 0.0 else 0
        sigmas[j] = sigma
        sds[j] = np.sqrt(sd_val)
    return sigmas, sds

from numba import njit

@njit
def choose_value_list(vec_input, vec_wykluczenia, a, b):
    count = 0
    for k in range(len(vec_wykluczenia)):
        idx = vec_wykluczenia[k] - 1
        val = vec_input[idx]
        if a < val < b:
            count += 1

    out_vals = np.empty(count)
    out_inds = np.empty(count, dtype=np.int64)

    pos = 0
    for k in range(len(vec_wykluczenia)):
        idx = vec_wykluczenia[k] - 1
        val = vec_input[idx]
        if a < val < b:
            out_vals[pos] = val
            out_inds[pos] = idx
            pos += 1

    return out_vals, out_inds



@njit
def fit_curve_factor_cl(data_input, sd_input, x_k):
    n = len(data_input)
    se2 = sd_input **2
    w = np.empty(n)
    for i in range(n):
        denom = (data_input[i] - 1) ** 2
        w[i] = 1.0 / np.sqrt(np.log(1.0 + se2[i] / denom)) if denom > 0.0 else 0
    y = np.log(data_input - 1.0)
    A = A_x = A_xx = A_y = A_xy = 0.0
    for i in range(n):
        wi = w[i]
        xi = x_k[i]
        yi = y[i]
        A += wi
        A_x += wi * xi
        A_xx += wi * xi * xi
        A_y += wi * yi
        A_xy += wi * xi * yi
    Delta = A * A_xx - A_x * A_x
    if Delta == 0.0:
        return 0.0, 0.0
    a_coef = (A * A_xy - A_x * A_y) / Delta
    b_coef = (A_xx * A_y - A_x * A_xy) / Delta
    return a_coef, b_coef

@njit
def wspolczynnik_reg_factor_cl(a_coef, b_coef, k_start, k_stop):
    n = k_stop - k_start + 1
    out = np.empty(n)
    for i in range(n):
        k = k_start + i
        out[i] = 1.0 + np.exp(a_coef * k + b_coef)
    return out
    
@njit
def triangle_forward_one_np(triangle_input, f, k_forward_start):
    mm, nn = triangle_input.shape
    req_cols = len(f)
    tri = np.zeros((mm, req_cols))
    # kopiuj istniejące dane
    for i in range(mm):
        for j in range(nn):
            tri[i, j] = triangle_input[i, j]
    # projekcja
    for j in range(k_forward_start - 1, len(f)):
        if j + 1 >= req_cols:
            continue
        max_row = max(0, mm - j - 1)
        for i in range(max_row, mm):
            tri[i, j + 1] = tri[i, j] * f[j]
    return tri



@njit
def fit_curve_factor_P_to_I(data_input, x_k):
    factor_input = np.log(1.0 - data_input)
    w_k_sqr = np.ones(len(data_input))

    A = np.sum(w_k_sqr)
    A_x = np.sum(w_k_sqr * x_k)
    A_xx = np.sum(w_k_sqr * x_k * x_k)
    A_y = np.sum(w_k_sqr * factor_input)
    A_xy = np.sum(w_k_sqr * x_k * factor_input)

    Delta = A * A_xx - A_x * A_x
    a_num = (A * A_xy - A_x * A_y) / Delta
    b_num = (A_xx * A_y - A_x * A_xy) / Delta

    return a_num, b_num

@njit
def vector_reverse_diagonal(data: np.ndarray):
    """Zwraca wektor elementów odwrotnej przekątnej (ostatniej pełnej diagonali)."""
    rows, cols = data.shape
    result = []
    for i in range(rows):
        j = cols - 1 - i
        if 0 <= j < cols:
            v = data[i, j]
            if not np.isnan(v):
                result.append(v)
    return np.array(result)


@njit
def wspolczynnik_reg_factor_P_to_I(a, b, k_start, k_stop):
    k_values = np.arange(k_start, k_stop + 1)
    exponent = np.exp(a * k_values + b)
    wartosci_reg = 1.0 - exponent
    return wartosci_reg

def choose_value_list_np(vec_input, vec_wykluczenia, a, b):
    count = 0
    for k in range(len(vec_wykluczenia)):
        idx = vec_wykluczenia[k] - 1
        val = vec_input[idx]
        if a < val < b:
            count += 1

    out_vals = np.empty(count)
    out_inds = np.empty(count, dtype=np.int64)

    pos = 0
    for k in range(len(vec_wykluczenia)):
        idx = vec_wykluczenia[k] - 1
        val = vec_input[idx]
        if a < val < b:
            out_vals[pos] = val
            out_inds[pos] = idx
            pos += 1

    return out_vals, out_inds

# z inflacja


data_incurred_pd = pd.DataFrame(triangle_incurred_2)
triangle_paid_infl_pd = pd.DataFrame(triangle_paid)
data_wagi_pi_pd = pd.DataFrame(data_wagi_pi)
data_incurred_pd = data_incurred_pd.copy()
r_j = yh.wspolczynnik_r(triangle_paid_infl_pd,data_incurred_pd,data_wagi_pi_pd)

# wspolczynniki do symulacyjnej

r_i_j = yh.wspolczynnik_r_i_j(triangle_paid_infl_pd,data_incurred_pd)
var_j = yh.wspolczynnik_var_j(data_incurred_pd,r_i_j,r_j,data_wagi_pi_pd)
res_i_j = wspolczynnik_res_i_j(r_i_j,r_j,var_j,data_incurred_pd,data_wagi_pi_pd)
lambda_cor = lambda_cerrelation(res_i_j)




